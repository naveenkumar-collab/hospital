rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a sophisticated Role-Based Access
     * Control (RBAC) model combined with a strict user-ownership principle for
     * patient-specific data. It distinguishes between Patients and various
     * Staff roles (Admin, Doctor, etc.) to grant granular permissions.
     *
     * Data Structure: Primary entities like patients, staff, and departments
     * are in top-level collections. Sensitive patient data, such as medical
     * records and bills, are nested within subcollections under the specific
     * patient's document (e.g., /patients/{patientId}/medicalRecords/{recordId}).
     * This structure provides clear, path-based ownership. Global roles
     * are managed in dedicated collections (e.g., /roles_admin) for efficient,
     * database-wide permission checks.
     *
     * Key Security Decisions:
     * - Default Deny: All access is denied unless explicitly granted.
     * - Role Collections: /roles_admin and /roles_doctor collections act as
     *   permission sets. A user's role is determined by the existence of a
     *   document with their UID in one of these collections. These collections
     *   are not client-writable.
     * - Patient Data Privacy: A patient can only access data under their own
     *   /patients/{patientId} path. Staff access to this data is restricted
     *   to those with appropriate roles (Admin, Doctor) or a direct, documented
     *   relationship (e.g., being the assigned doctor for an appointment).
     * - Denormalization for Authorization: The rules are designed to avoid slow
     *   and costly `get()` calls. For example, `appointment` documents contain
     *   both `patientId` and `staffId`, and `notification` documents for a
     *   department are expected to have a map of authorized staff UIDs. This
     *   makes authorization checks fast and efficient.
     * - Structural Segregation: Segregating patient-private data into
     *   subcollections simplifies security. Publicly readable data (like
     *   hospital services) is kept in separate top-level collections with
     *   different security rules.
     */

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Verifies the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies the requesting user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user has global Admin privileges by checking for
     * their document in the `roles_admin` collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user has Doctor privileges by checking for
     * their document in the `roles_doctor` collection.
     */
    function isDoctor() {
      return exists(/databases/$(database)/documents/roles_doctor/$(request.auth.uid));
    }

    /**
     * Checks if the user is a staff member.
     */
    function isStaff() {
      return exists(/databases/$(database)/documents/staff/$(request.auth.uid));
    }

    /**
     * Ensures an existing document is being updated/deleted by an admin.
     */
    function isExistingAdmin() {
      return isAdmin() && resource != null;
    }

    // ----------------------------------------------------------------------
    // Role-Defining Collections (Admin-managed)
    // ----------------------------------------------------------------------

    /**
     * @description Manages global Admin roles. Document ID is the staff UID.
     * These collections should only be managed server-side or via the Firebase
     * console, not by clients.
     * @path /roles_admin/{staffId}
     * @allow (none) No client-side operations are permitted.
     * @deny (any) All client-side reads and writes are rejected.
     * @principle Prevents privilege escalation by locking down role assignments.
     */
    match /roles_admin/{staffId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages global Doctor roles. Document ID is the staff UID.
     * These collections should only be managed server-side or via the Firebase
     * console, not by clients.
     * @path /roles_doctor/{staffId}
     * @allow (none) No client-side operations are permitted.
     * @deny (any) All client-side reads and writes are rejected.
     * @principle Prevents privilege escalation by locking down role assignments.
     */
    match /roles_doctor/{staffId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // ----------------------------------------------------------------------
    // Top-Level Collections
    // ----------------------------------------------------------------------

    /**
     * @description Patient profiles. A user can create and manage their own
     * profile. Admins and Doctors can view any profile.
     * @path /patients/{patientId}
     * @allow (create) An authenticated user creating their own patient profile.
     * @deny (get) A patient trying to read another patient's profile.
     * @principle Enforces self-service for profile creation and ownership for
     * subsequent access, with role-based overrides for authorized staff.
     */
    match /patients/{patientId} {
      allow get: if isOwner(patientId) || isAdmin() || isDoctor();
      allow list: if isAdmin() || isDoctor();
      allow create: if isOwner(patientId);
      allow update: if (isOwner(patientId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Staff profiles. Staff can manage their own profile. All
     * signed-in users can read basic staff info for communication. Admins can
     * manage all profiles.
     * @path /staff/{staffId}
     * @allow (get) Any signed-in user viewing a staff member's profile.
     * @deny (update) A staff member trying to update another staff member's profile.
     * @principle Combines self-management with broad read access for internal
     * transparency and admin oversight for management.
     */
    match /staff/{staffId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(staffId);
      allow update: if (isOwner(staffId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Hospital department information. Readable by any signed-in
     * user. Writable only by Admins or the designated Head of Department.
     * @path /departments/{departmentId}
     * @allow (get) Any authenticated user reading department details.
     * @deny (update) A staff member who is not an Admin or the department head
     * trying to change details.
     * @principle Provides public read access for organizational data while
     * restricting modifications to authorized roles.
     */
    match /departments/{departmentId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if (isAdmin() || isOwner(resource.data.headOfDepartmentId)) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Appointments between patients and staff. Accessible only by
     * the involved patient, the involved staff member, or an Admin.
     * @path /appointments/{appointmentId}
     * @allow (get) A patient viewing an appointment where their UID is the 'patientId'.
     * @deny (get) A patient or staff member trying to access an appointment
     * they are not a part of.
     * @principle Implements shared access by checking if the user's UID is one
     * of the denormalized participants on the document.
     */
    match /appointments/{appointmentId} {
      allow get: if isOwner(resource.data.patientId) || isOwner(resource.data.staffId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isSignedIn() && (isOwner(request.resource.data.patientId) || isOwner(request.resource.data.staffId) || isAdmin());
      allow update: if (isOwner(resource.data.patientId) || isOwner(resource.data.staffId) || isAdmin()) && resource != null;
      allow delete: if (isOwner(resource.data.patientId) || isOwner(resource.data.staffId) || isAdmin()) && resource != null;
    }

    /**
     * @description Medical services offered by the hospital. Readable by any
     * signed-in user. Writable only by Admins.
     * @path /services/{serviceId}
     * @allow (list) Any authenticated user listing available services.
     * @deny (create) A non-Admin user trying to add a new service.
     * @principle Public read access for general information, with writes
     * restricted to a global administrative role.
     */
    match /services/{serviceId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Notifications for staff. Accessible by the direct recipient
     * or any staff in the recipient department. Senders can create notifications.
     * @path /notifications/{notificationId}
     * @allow (get) A staff member reading a notification sent directly to them
     * ('recipientStaffId') or their department.
     * @deny (get) A staff member trying to read a notification not intended for them.
     * @principle Uses denormalized fields ('recipientStaffId' and a
     * 'authorizedDepartmentStaffIds' map) for efficient, direct access checks.
     */
    match /notifications/{notificationId} {
      function isNotificationRecipient() {
        return isOwner(resource.data.recipientStaffId) || (resource.data.authorizedDepartmentStaffIds != null && resource.data.authorizedDepartmentStaffIds[request.auth.uid] == true);
      }
      allow get: if isNotificationRecipient() || isAdmin();
      allow list: if isAdmin(); // Users must query for their own notifications.
      allow create: if isStaff() && (isAdmin() || isOwner(request.resource.data.senderStaffId));
      allow update: if (isNotificationRecipient() || isAdmin()) && resource != null;
      allow delete: if (isNotificationRecipient() || isAdmin()) && resource != null;
    }

    // ----------------------------------------------------------------------
    // Patient Subcollections
    // ----------------------------------------------------------------------

    /**
     * @description Medical records for a specific patient. Access is restricted
     * to the patient, Doctors, and Admins.
     * @path /patients/{patientId}/medicalRecords/{medicalRecordId}
     * @allow (get) The patient ('patientId' from path) reading their own record.
     * @deny (create) A patient trying to create their own medical record.
     * @principle Path-based ownership secures the data tree, with role-based
     * overrides for authorized medical and administrative staff.
     */
    match /patients/{patientId}/medicalRecords/{medicalRecordId} {
      function canWriteMedicalRecord() {
        return (isAdmin() || isDoctor());
      }
      function isValidNewMedicalRecord() {
        return request.resource.data.patientId == patientId && isOwner(request.resource.data.staffId);
      }
      function isImmutableMedicalRecord() {
        return request.resource.data.patientId == resource.data.patientId && request.resource.data.staffId == resource.data.staffId;
      }

      allow get: if isOwner(patientId) || isAdmin() || isDoctor();
      allow list: if isOwner(patientId) || isAdmin() || isDoctor();
      allow create: if canWriteMedicalRecord() && isValidNewMedicalRecord();
      allow update: if canWriteMedicalRecord() && resource != null && isImmutableMedicalRecord();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Bills for a specific patient. Accessible by the patient and Admins.
     * @path /patients/{patientId}/bills/{billId}
     * @allow (list) The patient ('patientId' from path) listing their own bills.
     * @deny (get) Another patient trying to access this patient's bill.
     * @principle Path-based ownership restricts access to the data owner, with
     * overrides for administrative staff responsible for billing.
     */
    match /patients/{patientId}/bills/{billId} {
      function isValidNewBill() {
        return request.resource.data.patientId == patientId;
      }
      function isImmutableBill() {
        return request.resource.data.patientId == resource.data.patientId;
      }

      allow get: if isOwner(patientId) || isAdmin();
      allow list: if isOwner(patientId) || isAdmin();
      allow create: if isAdmin() && isValidNewBill();
      allow update: if isAdmin() && resource != null && isImmutableBill();
      allow delete: if isAdmin() && resource != null;

      /**
       * @description Line items for a specific bill. Inherits permissions from the
       * parent bill. Accessible by the patient and Admins.
       * @path /patients/{patientId}/bills/{billId}/billItems/{billItemId}
       * @allow (get) The patient ('patientId' from path) reading their own bill items.
       * @deny (create) A patient trying to add an item to their own bill.
       * @principle Inherits security context from the parent path, ensuring
       * consistent ownership and permissions down the data hierarchy.
       */
      match /billItems/{billItemId} {
        function isValidNewBillItem() {
          return request.resource.data.billId == billId;
        }
        function isImmutableBillItem() {
          return request.resource.data.billId == resource.data.billId;
        }

        allow get: if isOwner(patientId) || isAdmin();
        allow list: if isOwner(patientId) || isAdmin();
        allow create: if isAdmin() && isValidNewBillItem();
        allow update: if isAdmin() && resource != null && isImmutableBillItem();
        allow delete: if isAdmin() && resource != null;
      }
    }
  }
}